---
import type { HTMLAttributes } from 'astro/types';

type Props = HTMLAttributes<'div'>;

const { class: className, ...rest } = Astro.props;
---

<div class:list={['starwind-dialog', className]} data-slot="dialog" {...rest}>
  <slot />
</div>

<script>
  class DialogHandler {
    private triggers: HTMLButtonElement[] = [];
    private dialog: HTMLDialogElement | null = null;
    private closeButtons: HTMLButtonElement[] = [];
    private backdrop: HTMLElement | null = null;
    private dialogId: string;
    private _closeTimeout: ReturnType<typeof setTimeout> | null = null;
    private _isClosing = false;
    /**
     * The duration of the animation in milliseconds. This is used to calculate the
     * duration of close animation before hiding the dialog and backdrop
     */
    private animationDuration: number;

    // Store bound handlers for cleanup
    private boundOpenHandler: (e: Event) => void = () => {};
    private boundCloseHandler: (e: Event) => void = () => {};
    private boundBackdropHandler: (e: MouseEvent) => void = () => {};
    private boundKeydownHandler: (e: KeyboardEvent) => void = () => {};
    private boundFormHandler: (e: SubmitEvent) => void = () => {};

    constructor(dialogWrapper: HTMLElement, dialogNumber: number) {
      this.dialog = dialogWrapper.querySelector('dialog');
      this.backdrop = dialogWrapper.querySelector('.starwind-dialog-backdrop');
      if (!this.dialog || !this.backdrop) {
        throw new Error('Dialog: dialog or backdrop not found');
      }

      // if no ID was provided for the wrapper, generate one
      if (dialogWrapper.id) {
        this.dialogId = dialogWrapper.id;
      } else {
        this.dialogId = `starwind-dialog${dialogNumber}`;
        dialogWrapper.id = this.dialogId;
      }

      // animationDuration is set with inline styles through passed prop to DialogContent
      // if no animationDuration, check data-close-duration
      const animationDurationString = this.dialog.style.animationDuration?.trim() || '';
      this.animationDuration = this.parseAnimationDuration(animationDurationString);

      // Find internal triggers and handle them
      const internalTriggers = dialogWrapper.querySelectorAll('.starwind-dialog-trigger');
      internalTriggers.forEach(triggerElement => {
        const tempTrigger = triggerElement as HTMLElement;
        let trigger: HTMLButtonElement | null = null;

        if (tempTrigger?.hasAttribute('data-as-child')) {
          const firstChild = tempTrigger.firstElementChild;
          if (firstChild && (firstChild instanceof HTMLButtonElement || firstChild.tagName === 'BUTTON')) {
            trigger = firstChild as HTMLButtonElement;
          } else if (tempTrigger.querySelector('button')) {
            trigger = tempTrigger.querySelector('button') as HTMLButtonElement;
          }
        } else if (tempTrigger && (tempTrigger instanceof HTMLButtonElement || tempTrigger.tagName === 'BUTTON')) {
          trigger = tempTrigger as HTMLButtonElement;
        }

        if (trigger) {
          this.triggers.push(trigger);
        }
      });

      // Find external triggers that target this dialog
      this.findExternalTriggers();

      // if closeButtons are set with asChild, swap the wrapper with its first child
      const tempCloseButtons = dialogWrapper.querySelectorAll('.starwind-dialog-close') as NodeListOf<HTMLElement>;
      tempCloseButtons.forEach((button: HTMLElement) => {
        if (button.hasAttribute('data-as-child')) {
          const childElement = button.firstElementChild;
          if (childElement) {
            childElement.classList.add('starwind-dialog-close');
            button.parentNode?.replaceChild(childElement, button);
          }
        }
      });

      // Convert NodeList to Array for consistency with triggers
      this.closeButtons = Array.from(dialogWrapper.querySelectorAll('.starwind-dialog-close')) as HTMLButtonElement[];

      // if essential elements are not there, exit
      if (!this.dialog || !this.backdrop) return;

      this.setupAccessibility(dialogNumber);
      this.setupEvents();
    }

    private setupAccessibility(dialogNumber: number): void {
      // get the first heading element in the dialog
      const firstHeading = this.dialog?.querySelector('h1, h2, h3, h4, h5, h6');
      if (firstHeading) {
        // create a unique ID for the heading
        firstHeading.id = `starwind-dialog${dialogNumber}-heading`;
        // set the aria-labelledby attribute to the first heading element
        this.dialog?.setAttribute('aria-labelledby', firstHeading.id);
      }
    }

    /**
     * Find all external triggers that target this dialog
     */
    private findExternalTriggers(): void {
      const externalTriggers = document.querySelectorAll(
        `.starwind-dialog-trigger[data-dialog-for="${this.dialogId}"]`
      );

      externalTriggers.forEach(triggerElement => {
        // Skip if this is an internal trigger we already processed
        const dialogWrapper = triggerElement.closest('.starwind-dialog');
        if (dialogWrapper && dialogWrapper.id === this.dialogId) {
          return;
        }

        let trigger: HTMLButtonElement;
        if (triggerElement.hasAttribute('data-as-child')) {
          trigger = triggerElement.firstElementChild as HTMLButtonElement;
        } else {
          trigger = triggerElement as HTMLButtonElement;
        }

        if (trigger && !this.triggers.includes(trigger)) {
          this.triggers.push(trigger);
        }
      });
    }

    private parseAnimationDuration(animationDurationString: string): number {
      // Early return for empty or falsy values
      if (!animationDurationString) {
        const fallback = this.dialog?.dataset.closeDuration ? parseFloat(this.dialog.dataset.closeDuration) : 200;
        return isFinite(fallback) ? fallback : 200;
      }

      // Check for explicit unit patterns
      if (/^\d+(\.\d+)?ms$/i.test(animationDurationString)) {
        const value = parseFloat(animationDurationString);
        return isFinite(value) ? value : 200;
      }

      if (/^\d+(\.\d+)?s$/i.test(animationDurationString)) {
        const value = parseFloat(animationDurationString) * 1000;
        return isFinite(value) ? value : 200;
      }

      // Check for plain number
      if (/^\d+(\.\d+)?$/.test(animationDurationString)) {
        const value = parseFloat(animationDurationString);
        return isFinite(value) ? value : 200;
      }

      // Fallback for unrecognized formats
      const fallback = this.dialog?.dataset.closeDuration ? parseFloat(this.dialog.dataset.closeDuration) : 200;
      return isFinite(fallback) ? fallback : 200;
    }

    public cleanup(): void {
      // Clear any pending timeout
      if (this._closeTimeout) {
        clearTimeout(this._closeTimeout);
        this._closeTimeout = null;
      }

      // Reset closing flag
      this._isClosing = false;

      // Remove event listeners
      this.triggers.forEach(trigger => {
        if (this.boundOpenHandler) {
          trigger.removeEventListener('click', this.boundOpenHandler);
        }
      });

      this.closeButtons.forEach(button => {
        if (this.boundCloseHandler) {
          button.removeEventListener('click', this.boundCloseHandler);
        }
      });

      if (this.dialog && this.boundBackdropHandler) {
        this.dialog.removeEventListener('click', this.boundBackdropHandler);
      }

      if (this.dialog && this.boundKeydownHandler) {
        this.dialog.removeEventListener('keydown', this.boundKeydownHandler);
      }

      // Remove form listeners
      const forms = this.dialog?.querySelectorAll('form');
      forms?.forEach(form => {
        if (this.boundFormHandler) {
          form.removeEventListener('submit', this.boundFormHandler);
        }
      });
    }

    private setupEvents(): void {
      if (!this.dialog) return;

      // Create bound handlers for cleanup
      this.boundOpenHandler = () => this.open();
      this.boundCloseHandler = () => {
        const openDialogs = document.querySelectorAll('dialog[open]');
        if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
          this.close();
        }
      };
      this.boundBackdropHandler = (e: MouseEvent) => {
        if (!this.dialog) return;
        const dialogDimensions = this.dialog.getBoundingClientRect();
        const clickedInDialog =
          e.clientX >= dialogDimensions.left &&
          e.clientX <= dialogDimensions.right &&
          e.clientY >= dialogDimensions.top &&
          e.clientY <= dialogDimensions.bottom;

        if (!clickedInDialog) {
          const openDialogs = document.querySelectorAll('dialog[open]');
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        }
      };
      this.boundKeydownHandler = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          const openDialogs = document.querySelectorAll('dialog[open]');
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        }
      };
      this.boundFormHandler = (e: SubmitEvent) => {
        const form = e.target as HTMLFormElement;
        if (form.method === 'dialog') {
          e.preventDefault();
          const openDialogs = document.querySelectorAll('dialog[open]');
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        }
      };

      // Add click listeners to all triggers
      this.triggers.forEach(trigger => {
        trigger.addEventListener('click', this.boundOpenHandler);
      });

      // Add click handlers to all close buttons
      this.closeButtons?.forEach(button => {
        button.addEventListener('click', this.boundCloseHandler);
      });

      // Close on click outside
      this.dialog.addEventListener('click', this.boundBackdropHandler);

      // Handle escape key
      this.dialog.addEventListener('keydown', this.boundKeydownHandler);

      // Intercept form submissions to handle dialog close
      const forms = this.dialog.querySelectorAll('form');
      forms.forEach(form => {
        form.addEventListener('submit', this.boundFormHandler);
      });
    }

    private open(): void {
      if (!this.dialog || !this.backdrop) return;
      this.dialog.showModal();
      document.body.classList.add('overflow-hidden');
      this.backdrop.classList.remove('hidden');
      this.backdrop.dataset.state = 'open';
      this.dialog.dataset.state = 'open';
    }

    private close(): void {
      if (!this.dialog || !this.backdrop) return;

      // Check if backdrop already has hidden class or is already closing
      if (this.backdrop.classList.contains('hidden') || this._isClosing) {
        return;
      }

      this._isClosing = true;
      this.dialog.dataset.state = 'closed';
      this.backdrop.dataset.state = 'closed';

      // Clear any existing timeout before scheduling a new one
      if (this._closeTimeout) {
        clearTimeout(this._closeTimeout);
      }

      // Wait for animation to finish before hiding backdrop
      this._closeTimeout = setTimeout(() => {
        this.backdrop?.classList.add('hidden');
        this.dialog?.close();
        const stillOpen = document.querySelectorAll('dialog[open]').length;
        if (stillOpen === 0) {
          document.body.classList.remove('overflow-hidden');
        }
        // Reset flags when timeout callback runs
        this._isClosing = false;
        this._closeTimeout = null;
      }, this.animationDuration);
    }
  }

  // Store instances in a Map for cleanup management
  const dialogInstances = new Map<HTMLElement, DialogHandler>();

  // Initialize all dialogs
  const setupDialogs = () => {
    document.querySelectorAll('.starwind-dialog').forEach((dialogWrapper, idx) => {
      const wrapper = dialogWrapper as HTMLElement;

      // Clean up existing instance if it exists
      const existingInstance = dialogInstances.get(wrapper);
      if (existingInstance) {
        existingInstance.cleanup();
      }

      // Create new instance
      dialogInstances.set(wrapper, new DialogHandler(wrapper, idx));
    });
  };

  setupDialogs();
  document.addEventListener('astro:after-swap', setupDialogs);
</script>

<style>
  .overflow-hidden {
    overflow: hidden;
  }
</style>
